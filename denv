#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-only
#
# This file is part of the denv project: https://github.com/tomeichlersmith/denv
#
# Copyright (C) 2021 denv contributors
#
# denv is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.
#
# denv is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with denv; if not, see <http://www.gnu.org/licenses/>.

denv_version=0.1.0

# POSIX
set -o errexit
set -o nounset

# deduce full path to our executable so we can locate the entrypoint executable
denv_fullpath="$(realpath "$0" || true)"
# deduce full path to entrypoint executable
denv_entrypoint="$(dirname "${denv_fullpath}" || true)/_denv_entrypoint"

if [ -n "${DENV_DEBUG+x}" ]; then
  set -o xtrace
fi

if [ -n "${DENV_INFO+x}" ]; then
  _denv_info() {
    printf "\033[32;1m INFO: \033[0m\033[32m%s\n" "$1"
    shift
    while [ "$#" -gt "0" ]; do
      printf '       %s\n' "$1"
      shift
    done
    printf "\033[0m"
  }
else
  _denv_info() {
    :
  }
fi

# print each argument on its own line with the first line
# prefixed with "ERROR: ".
_denv_error() {
  printf >&2 "\033[1;31mERROR: \033[0m\033[31m%s\n" "$1"
  shift
  while [ "$#" -gt "0" ]; do
    printf >&2 "       %s\n" "$1"
    shift
  done
  printf >&2 "\033[0m"
}

###################################################################################################
# helper functions that can be shared across runners
###################################################################################################

# convert the ${denv_image} variable into a filename stub
# Arguments
#  denv_image environment variable
# Outputs
#  a simple filename with special characters replaced for
#  easier interaction with the filesystem
_denv_image_to_filename() {
  # convert slashes to underscores and colons to hyphens
  printf '%s' "${denv_image}" | tr '/' '_' | tr ':' '-'
}

# convert the space-separate mounts array into the space-separate
# list of arguments to provide to run command
# Arguments
#  1 - option name to prefix each mount with
#  2 - optional mount setting to append to the mount
#  denv_mounts - env var holding space-separated list of mounts
# Outputs
#  the list of mount-related arguments to provide to run command
_denv_mounts_to_args() {
  mount_args=""
  for mount in ${denv_mounts}; do
    mount_args="${1} ${mount}:${mount}${2:+:${2}} ${mount_args}"
  done
  echo "${mount_args}"
}

###################################################################################################
# container runner interface
#
# all container runners must edit the functions here
###################################################################################################

# 1. _denv_runner : print name and version of runner to stdout
_denv_runner() {
  case "${denv_runner}" in
    docker|podman|apptainer|singularity)
      ${denv_runner} --version
      ;;
    norunner)
      echo "norunner v0.0.0"
      ;;
    *)
      _denv_error "This should never happen."
      exit 125
      ;;
  esac
}

# 2. _denv_image_exists : check ${denv_image} exists locally
#   - return 0 if it does exist, and 1 if it doesn't exist
_denv_image_exists() {
  _denv_info "checking if ${denv_image} exists"
  case "${denv_runner}" in
    docker|podman)
      images_matching_tag="$(${denv_runner} images -q "${denv_image}" 2> /dev/null)"
      test -n "${images_matching_tag}"
      return $?
      ;;
    apptainer|singularity)
      [ -d "${denv_image_cache}" ] || return 1;
      # I want to ignore the return value of this function since it
      # is just writing a hidden filename for caching the image used by denv
      # shellcheck disable=SC2312
      test -f "${denv_image_cache}/$(_denv_image_to_filename).sif"
      return $?
      ;;
    norunner)
      [ -d "${denv_image_cache}" ] || return 1;
      # I want to ignore the return value of this function since it
      # is just writing a hidden filename for caching the image used by denv
      # shellcheck disable=SC2312
      test -f "${denv_image_cache}/$(_denv_image_to_filename)"
      return $?
      ;;
    *)
      _denv_error "This should never happen"
      return 125
      ;;
  esac
}

# 3. _denv_pull : pull down ${denv_image} to a local copy
#   - runners can use the directory ${denv_image_cache}
#     to store image files if the runner requires the user to specify files
#   - use _denv_image_to_filename function if you need a filename
#     for a given image tag
_denv_pull() {
  _denv_info "pulling ${denv_image}"
  case "${denv_runner}" in
    docker|podman)
      ${denv_runner} pull "${denv_image}"
      ;;
    apptainer|singularity)
      [ -d "${denv_image_cache}" ] || mkdir -p "${denv_image_cache}"
      # I want to ignore the return value of this function since it
      # is just writing a hidden filename for caching the image used by denv
      # shellcheck disable=SC2312
      sif_file="${denv_image_cache}/$(_denv_image_to_filename).sif"
      image_full="${denv_image}"
      echo "${denv_image}" | grep -v '://' && image_full="docker://${denv_image}"
      ${denv_runner} build \
        --force \
        "${sif_file}" \
        "${image_full}"
      ;;
    norunner)
      mkdir -p "${denv_image_cache}"
      # I want to ignore the return value of this function since it
      # is just writing a hidden filename for caching the image used by denv
      # shellcheck disable=SC2312
      touch "${denv_image_cache}/$(_denv_image_to_filename)"
      ;;
    *)
      _denv_error "This should never happen"
      return 125
      ;;
  esac
}

# 4. _denv_run : run the container
#   - entrypoint is the denv-entrypoint program 
#   - use image ${denv_image} 
#   - set home directory in the container to ${denv_workspace}
#   - set user and group in container to current user and group
#   - attach all mounts in space-separated list "${denv_mounts}"
#   - pass on all current environment variables
#     as well as the DENV_* variables
#   - set SHELL to be ${denv_shell} in container
_denv_run() {
  # shellcheck disable=SC2312
  _hostname="${denv_name}.$(uname -n || true)"
  # we will be running now and not writing the config
  # so we can update the denv_mounts list
  [ -d /tmp/.X11-unix ] && denv_mounts="${denv_mounts} /tmp/.X11-unix"
  denv_mounts="${denv_mounts} ${denv_entrypoint}"
  case "${denv_runner}" in
    docker|podman)
      interactive=""
      if tty -s; then
        interactive="--interactive --tty"
      fi
      # and need to mount group definition file
      # mounting the passwd and group files may not work if host or contianer OS do not look 
      # there for user/group definitions
      denv_mounts="${denv_mounts} /etc/passwd /etc/group"
      # I want to ignore the return value of this function since it
      # is just concatenating strings for me
      # shellcheck disable=SC2312
      mounts="$(_denv_mounts_to_args "--volume")"
      # need to mount workspace in a special way for podman
      # https://github.com/containers/podman/commit/82a050a58f2ef2cf940c2ef49e1f8c4b17ab8beb
      if [ "${denv_runner}" = "podman" ]; then
        # shellcheck disable=SC2312
        #mounts="${mounts} --volume ${denv_workspace}:${denv_workspace}:idmap"
        mounts="${mounts} --volume ${denv_workspace}:${denv_workspace}"
      else
        mounts="${mounts} --volume ${denv_workspace}:${denv_workspace}"
      fi
      environment="--env DENV_NAME=${denv_name}
      --env DENV_RUNNER=${denv_runner}
      --env DENV_IMAGE=${denv_image}
      --env HOME=${denv_workspace}"
      # deduce env variables, copied from distrobox
      set +o xtrace # disable trace for this snippet
      for i in $(printenv | grep '=' | grep -Ev ' |"|`|\$' | \
        grep -Ev '^(HOST|HOSTNAME|HOME|LANG|LC_CTYPE|PATH|SHELL|XDG_.*_DIRS|^_)'); do
        # environment filtered to ignore strange variables that are multiline or contain spaces in their values
        # we also need to exclude important variables that we are defining special for the conatiner like HOME,
        # HOSTNAME, and PATH
        environment="--env ${i} ${environment}"
      done
      if [ -n "${DENV_DEBUG+x}" ]; then
        # renable trace
        set -o xtrace
        # add to the environment
        environment="${environment} --env DENV_DEBUG=${DENV_DEBUG}"
      fi
      # I'm going to go ahead and assume that the user running this program
      # and currently configured in this shell is a valid user
      # shellcheck disable=SC2312
      userspec="$(id -u "${USER}"):$(id -g "${USER}")"
      # until podman makes a release v4.6.0 with idmap
      # the simplest solution is to just have the in-container user be root
      # https://github.com/containers/podman/commit/82a050a58f2ef2cf940c2ef49e1f8c4b17ab8beb
      if [ "${denv_runner}" = "podman" ]; then
        userspec="root"
      fi
      # shellcheck disable=SC2086
      ${denv_runner} run \
        --rm \
        ${interactive} \
        ${mounts} \
        --hostname "${_hostname}" \
        ${environment} \
        --workdir "${PWD}" \
        --entrypoint "${denv_entrypoint}" \
        --user "${userspec}" \
        "${denv_image}" \
        "$@"
      ;;
    apptainer|singularity)
      # apptainer/singularity do not pull automatically when attempting to run
      _denv_config_checked_pull DO_NOT_PROMPT_USER
      # I want to ignore the return value of this function since it
      # is just concatenating strings for me
      # shellcheck disable=SC2312
      mounts="$(_denv_mounts_to_args "--bind")"
      # shellcheck disable=SC2312
      sif_file="${denv_image_cache}/$(_denv_image_to_filename).sif"
      # shellcheck disable=SC2086
      ${denv_runner} exec \
        --hostname "${_hostname}" \
        --home "${denv_workspace}" \
        --env DENV_NAME="${denv_name}" \
        --env DENV_RUNNER=${denv_runner} \
        --env DENV_IMAGE=${denv_image} \
        ${mounts} \
        "${sif_file}" \
        "${denv_entrypoint}" \
        "$@"
      ;;
    norunner)
      echo "running ${denv_image} with "
      echo "  HOME=\"${denv_workspace}\""
      echo "  SHELL=\"${denv_shell}\""
      echo "  PWD=\"${PWD}\""
      # I want to ignore the return value of this function since it
      # is just concatenating strings for me
      # shellcheck disable=SC2312
      [ -z "${denv_mounts}" ] || echo "  $(_denv_mounts_to_args "--bind")"
      ;;
    *)
      _denv_error "This should never happen."
      return 125
      ;;
  esac
}

###################################################################################################
# denv internal helper functions
# 
#  these are the functions defining the CLI, loading the config, writing the config
#  and calling the runner functions defined above in the correct sequence
###################################################################################################

_denv_deduce_workspace() {
  # start from PWD and go up directories until file .denv
  # or reach root directory
  denv_workspace="${PWD}"
  while [ "${denv_workspace}" != "/" ]; do
    if [ -d "${denv_workspace}/.denv" ]; then
      return 0
    fi
    denv_workspace="$(dirname "${denv_workspace}" || true)"
  done
  _denv_error "Unable to deduce a denv workspace!" \
    "Are you in a denv workspace? Do you still need to 'denv init'?"
  return 1
}

# load the denv config from the input workspace
# Arguments
#  ${denv_workspace} env var
# Outputs
#  loaded config into runtime shell environment
_denv_load_config() {
  # deduce workspace if it isn't already defined
  if [ -z "${denv_workspace+x}" ]; then
    _denv_deduce_workspace
  fi
  # I am choosing to allow sourcing unknown code
  # shellcheck disable=SC1091
  . "${denv_workspace}/.denv/config"
  denv_image_cache="${denv_workspace}/.denv/images"
  if [ -z "${denv_runner+x}" ]; then
    if [ -n "${DENV_RUNNER+x}" ]; then
      denv_runner="${DENV_RUNNER}"
      if ! command -v "${denv_runner}" >/dev/null 2>&1; then
        _denv_error "The container runner set via DENV_RUNNER=${DENV_RUNNER} is not a valid command." \
          "You should only be setting DENV_RUNNER if you have more than one runner installed and wish to use denv with a specific one."
        return 1
      fi
    elif command -v docker >/dev/null 2>&1; then
      denv_runner="docker"
    elif command -v podman >/dev/null 2>&1; then
      denv_runner="podman"
    elif command -v apptainer >/dev/null 2>&1; then
      denv_runner="apptainer"
    elif command -v singularity >/dev/null 2>&1; then
      denv_runner="singularity"
    else
      _denv_error "No container runner available." \
        "Setting 'norunner' which simply allows exploration of CLI."
      denv_runner="norunner"
    fi
    _denv_info "using ${denv_runner} as runner"
  fi
}

# write the current config to the file
# Arguments
#  ${denv_workspace} env var
#  env - config variables from runtime env
_denv_write_config() {
  config="${denv_workspace}/.denv/config"
  { 
    echo "denv_name=\"${denv_name}\"";
    echo "denv_image=\"${denv_image}\"";
    echo "denv_shell=\"${denv_shell}\"";
    echo "denv_mounts=\"${denv_mounts}\"";
  } > "${config}"
}

# print the current denv config
# Arguments
#  all denv_* env vars
_denv_config_print() {
  printf "%s=\"%s\"\n" denv_workspace "${denv_workspace}"
  printf "%s=\"%s\"\n" denv_name "${denv_name}"
  printf "%s=\"%s\"\n" denv_image "${denv_image}"
  printf "%s=\"%s\"\n" denv_mounts "${denv_mounts}"
  printf "%s=\"%s\"\n" denv_shell "${denv_shell}"
  _denv_runner
}

# pull down the ${denv_image} if it doesn't exist
# locally, if it does exist locally, check
# with the user if they wish for denv to pull
# Arguments
#  1 - disable user prompt if provided, just assume no pull
#  denv_image (same as _denv_image_exists and _denv_pull)
_denv_config_checked_pull() {
  # I do want to fail-quiet here and so I implicitly
  # disable the 'set -e' flag which would normally
  # exit the program with any non-zero exit status
  # shellcheck disable=SC2310
  if ! _denv_image_exists; then
    _denv_pull
  elif [ -z "${1+x}" ]; then
    printf "\033[1m%s already exists on this computer - re-pull it?\033[0m [Y/n] " "${denv_image}"
    read -r ans
    case "${ans}" in
      Y|y)
        _denv_pull
        ;;
      *)
        echo "Not pulling ${denv_image}..."
        ;;
    esac
  fi
}

# update the image used by the denv
# Arguments
#  1 - new image for the denv
_denv_config_image() {
  case "$1" in
    pull)
      # if argument is keyword 'pull' then we simply
      # pull down with the currently configured image tag
      _denv_pull
      ;;
    *)
      # any other argument should be treated as the 
      # new image tag to use for the denv
      denv_image="$1"
      _denv_config_checked_pull "${DENV_NOPROMPT+DONT_PROMPT_USER}"
      ;;
  esac
}

# set the shell to be used in the container
# Arguments
#  1+ - command to use as shell in the container
# Outputs
#  sets denv_shell to the entire list of arguments
_denv_config_shell() {
  denv_shell="$*"
}

# add another mount point for the container
# Arguments
#  1+ - path to directory to mount to container
# Outputs
#  updates denv_mounts to include passed directories
_denv_config_mounts() {
  while [ "$#" -gt "0" ]; do
    case "$1" in
      /*)
        # this is a full path
        if [ -d "$1" ]; then
          denv_mounts="$1 ${denv_mounts}"
        else
          _denv_error "'$1' does not exist."
          return 1
        fi
        ;;
      *)
        _denv_error "'$1' is not a full path"
        return 1
        ;;
    esac
    shift
  done
}

# config some config variable
# Arguments
#  1 - varible to config
#  2 - new value for that variable
_denv_config_help() {
  cat <<\HELP

  denv config [help|-h|--help]
  denv config print
  denv config image [pull|IMAGE]
  denv config mounts DIR0 [DIR1 DIR2 ...]
  denv config shell SHELL

 COMMANDS
  help    print this help and exit
  print   print the deduced config for viewing
  image   set the image you wish to use
          the special keyword 'pull' can be used to
          not change the image being used but to re-download
          the same tag from the remote repository
  mounts  add one or more directories to be mounted to the denv
  shell   change which program is executed when opening
          the denv without any arguments

HELP
}
_denv_config() {
  if [ $# -eq 0 ]; then
    _denv_config_help
    return 0
  fi
  case "$1" in
    print)
      _denv_load_config
      cmd="_denv_config_${1}"
      ${cmd}
      ;;
    image|shell|mounts)
      _denv_load_config
      cmd="_denv_config_${1}"
      if [ "$#" -eq "1" ]; then
        _denv_config_help
        _denv_error "$1 requires an argument."
        return 1
      fi
      shift
      # I think I know what I'm doing
      # shellcheck disable=SC2068
      ${cmd} $@ 
      _denv_write_config
      ;;
    help|-h|--help)
      _denv_config_help
      ;;
    *)
      _denv_error "Unrecognized config argument '$1'"
      return 1
      ;;
  esac
}

# create a new denv workspace
_denv_init_help() {
  cat <<\HELP

  denv init [help|-h|--help] IMAGE [WORKSPACE] [--no-gitignore]
            [--force] [--name NAME]

 ARGUMENT
  help       : print this help and exit
  IMAGE      : the container image to use for running the denv
  WORKSPACE  : the directory to create the denv for
               optional, defaults to present working directory
  
 OPTIONS
  -h, --help     : print this help and exit
  --no-gitignore : don't generate a gitignore for the .denv directory
  --force        : overwrite an existing denv if it exists
  --name         : set a name for this denv

HELP
}
_denv_init() {
  # check for help request
  if [ $# -eq 0 ]; then
    _denv_init_help
    _denv_error "Provide at least an image to use for running"
    return 1
  fi
  gitignore=1
  force=1
  positionals=""
  while [ "$#" -gt "0" ]; do
    case "$1" in
      help|-h|-help)
        _denv_init_help
        return 0
        ;;
      --no-gitignore)
        gitignore=0
        ;;
      --force)
        force=0
        ;;
      --name)
        if [ -z "${2+x}" ]; then
          _denv_error "The '$1' option requires an argument after it."
          return 1
        fi
        denv_name="${2}"
        shift
        ;;
      *)
        positionals="${positionals} ${1}"
        ;;
    esac
    shift
  done
  # I want to re-split the positional arguments because neither
  # of them should have a space inside
  # shellcheck disable=SC2086
  set -- ${positionals}
  # image - first positional and only required argument
  image="$1"
  shift
  # workspace - second positional argument or PWD
  if [ "$#" -eq 0 ]; then
    denv_workspace="${PWD}"
  else
    denv_workspace="$1"
  fi

  # check if we already been init'ed
  if [ -d "${denv_workspace}/.denv" ];then
    if [ "${force}" = "0" ]; then
      _denv_info "overwriting previous denv workspace"
      rm -rf "${denv_workspace}/.denv"
    elif [ -n "${DENV_NOPROMPT+x}" ]; then
      _denv_error "denv prompt disabled but unwilling to delete a denv without user input."
      return 1
    else
      printf "\033[1mThis workspace already has a denv. Would you like to overwrite it?\033[0m [Y/n] "
      read -r ans
      case "${ans}" in
        Y|y)
          # delete old denv and continue below
          rm -rf "${denv_workspace}/.denv"
          ;;
        *)
          _denv_info "Exiting without modifying..."
          return 0
          ;;
      esac
    fi
  fi

  # set the default denv name to the workspace directory name
  if [ -z "${denv_name+x}" ]; then
    denv_name="$(basename "${denv_workspace}")"
  fi
  # we have a clean workspace directory, lets make a new denv
  denv_image="${image}"
  denv_shell="/bin/bash -i"
  denv_mounts=""
  mkdir "${denv_workspace}/.denv"
  _denv_write_config
  if [ "${gitignore}" = "1" ]; then
    _denv_info "Writing a gitignore for the .denv directory."
    cat > "${denv_workspace}/.denv/.gitignore" <<\GITIGNORE
# ignore everything in this directory
*
# except the config which folks might want to share
# across many computers
!config
GITIGNORE
  fi

  # reload config for any deduced parameters
  _denv_load_config
  _denv_config_checked_pull "${DENV_NOPROMPT+DONT_PROMPT_USER}"
}

# print the denv version
_denv_version() {
  echo "denv v${denv_version}"
}

# root program denv
_denv_help() {
  cat <<\HELP

  denv [COMMAND] [args...]

 DESCRIPTION
  interact with a containerized developers environment

  If no COMMAND is provided, open an interactive shell in
  the currently configured denv.

 COMMANDS
  version : print the version of denv
  init    : initialize a new denv with an image
  config  : modify current denv configuration
  help    : print this help and exit
  <cmd>   : run <cmd> inside denv container

HELP
}
_denv() {
  if [ $# -eq 0 ]; then
    _denv_load_config
    # shellcheck disable=SC2086
    _denv_run ${denv_shell}
    return $?
  fi

  case "$1" in
    -h|--help)
      _denv_help
      return 
      ;;
    version|help|config|init)
      cmd="_denv_${1}"
      shift
      # I think I know what I'm doing here
      # shellcheck disable=SC2068
      ${cmd} $@
      return $?
      ;;
    *)
      _denv_load_config
      # I think I know what I'm doing here
      # shellcheck disable=SC2068
      _denv_run $@
      return $?
      ;;
  esac
}

# I think I know what I'm doing here
# shellcheck disable=SC2068
_denv $@
