#!/bin/sh
# SPDX-License-Identifier: GPL-3.0-only
#
# This file is part of the denv project: https://github.com/tomeichlersmith/denv
#
# Copyright (C) 2021 denv contributors
#
# denv is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3
# as published by the Free Software Foundation.
#
# denv is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with denv; if not, see <http://www.gnu.org/licenses/>.

denv_version=0.8.0

# POSIX
set -o errexit
set -o nounset

# deduce full path to our executable so we can locate the entrypoint executable
# we need to write our own function to deduce the full path to denv
# because MacOS does not have the 'realpath' function out of the box.
denv_install_dir="$(dirname "$0")"
denv_install_dir="$(cd "${denv_install_dir}" && pwd -P)"
denv_fullpath="${denv_install_dir}/denv"
# deduce full path to entrypoint executable
denv_entrypoint="$(dirname "${denv_fullpath}" || true)/_denv_entrypoint"

if [ -n "${DENV_DEBUG+x}" ]; then
  set -o xtrace
fi

if [ -n "${DENV_INFO+x}" ]; then
  _denv_info() {
    printf "\033[32;1m INFO: \033[0m\033[32m%s\n" "$1"
    shift
    while [ "$#" -gt "0" ]; do
      printf '       %s\n' "$1"
      shift
    done
    printf "\033[0m"
  }
else
  _denv_info() {
    :
  }
fi

# print each argument on its own line with the first line
# prefixed with "ERROR: ".
_denv_error() {
  printf >&2 "\033[1;31mERROR: \033[0m\033[31m%s\n" "$1"
  shift
  while [ "$#" -gt "0" ]; do
    printf >&2 "       %s\n" "$1"
    shift
  done
  printf >&2 "\033[0m"
}

###################################################################################################
# helper functions that can be shared across runners
###################################################################################################

# convert the ${denv_image} variable into a filename stub
# Arguments
#  denv_image environment variable
# Outputs
#  a simple filename with special characters replaced for
#  easier interaction with the filesystem
_denv_image_to_filename() {
  # convert slashes to underscores and colons to hyphens
  printf '%s' "${denv_image}" | tr '/' '_' | tr ':' '-'
}

# convert the space-separate mounts array into the space-separate
# list of arguments to provide to run command
# Arguments
#  1 - option name to prefix each mount with
#  2 - optional mount setting to append to the mount
#  denv_mounts - env var holding space-separated list of mounts
# Outputs
#  the list of mount-related arguments to provide to run command
_denv_mounts_to_args() {
  mount_args=""
  for mount in ${denv_mounts}; do
    mount_args="${1} ${mount}:${mount}${2:+:${2}} ${mount_args}"
  done
  echo "${mount_args}"
}

# convert the environment variable related configuration parameters
# to a string list of arguments for the container runner
# Arguments
#  1 - option name to prefix each environment variable with
#  denv_environment - space-separated key=value pairs to put into the denv
# Outputs
#  list of env-var-related arugments to provide to run command
_denv_environment_to_args() {
  env_args=""
  for ev in ${denv_environment}; do
    env_args="${1} ${ev} ${env_args}"
  done
  echo "${env_args}"
}

###################################################################################################
# container runner interface
#
# all container runners must edit the functions here
###################################################################################################

# 1. _denv_runner : print name and version of runner to stdout
_denv_runner() {
  case "${denv_runner}" in
    docker|podman|apptainer|singularity)
      ${denv_runner} --version
      ;;
    norunner)
      echo "norunner v0.0.0"
      ;;
    *)
      _denv_error "This should never happen."
      exit 125
      ;;
  esac
}

# 2. _denv_image_exists : check ${denv_image} exists locally
#   - return 0 if it does exist, and 1 if it doesn't exist
_denv_image_exists() {
  _denv_info "checking if ${denv_image} exists"
  case "${denv_runner}" in
    docker|podman)
      images_matching_tag="$(${denv_runner} images -q "${denv_image}" 2> /dev/null)"
      test -n "${images_matching_tag}"
      return $?
      ;;
    apptainer|singularity)
      if [ -z "${denv_image_cache+x}" ]; then
        test -e "${denv_image}"
        return $?
      else
        [ -d "${denv_image_cache}" ] || return 1;
        test -e "${denv_image_cache}/$(_denv_image_to_filename).sif"
        return $?
      fi
      ;;
    norunner)
      [ -d "${denv_image_cache}" ] || return 1;
      test -f "${denv_image_cache}/$(_denv_image_to_filename)"
      return $?
      ;;
    *)
      _denv_error "This should never happen"
      return 125
      ;;
  esac
}

# 3. _denv_pull : pull down ${denv_image} to a local copy
#   - runners can use the directory ${denv_image_cache}
#     to store image files if the runner requires the user to specify files
#   - use _denv_image_to_filename function if you need a filename
#     for a given image tag
_denv_pull() {
  _denv_info "pulling ${denv_image}"
  case "${denv_runner}" in
    docker|podman)
      ${denv_runner} pull "${denv_image}"
      ;;
    apptainer|singularity)
      [ -d "${denv_image_cache}" ] || mkdir -p "${denv_image_cache}"
      sif_file="${denv_image_cache}/$(_denv_image_to_filename).sif"
      if [ -e "${denv_image}" ]; then
        _denv_info "This path exists on the filesystem, assuming unpacked image."
        # if the passed image is a file system path,
        # we assume it is an already unpacked image
        # and so we just symlink to it in our cache
        ln -s "${denv_image}" "${sif_file}" 
      else
        _denv_info "Image does not exist on filesystem, assuming registry tag."
        # passed image is not a file so we assume it
        # is the name of an image in some remote registry
        # using the docker:// registry as default
        image_full="${denv_image}"
        echo "${denv_image}" | grep -v '://' && image_full="docker://${denv_image}"
        ${denv_runner} build \
          --force \
          "${sif_file}" \
          "${image_full}"
      fi
      ;;
    norunner)
      mkdir -p "${denv_image_cache}"
      touch "${denv_image_cache}/$(_denv_image_to_filename)"
      ;;
    *)
      _denv_error "This should never happen"
      return 125
      ;;
  esac
}

# 4. _denv_run : run the container
#   - entrypoint is the denv-entrypoint program 
#   - use image ${denv_image} 
#   - set home directory in the container to ${denv_workspace}
#   - set user and group in container to current user and group
#   - attach all mounts in space-separated list "${denv_mounts}"
#   - pass on all current environment variables
#     as well as the DENV_* variables
#   - set SHELL to be ${denv_shell} in container
_denv_run() {
  _hostname="${denv_name}.$(uname -n || true)"
  # we will be running now and not writing the config
  # so we can update the denv_mounts list
  [ -d /tmp/.X11-unix ] && denv_mounts="${denv_mounts} /tmp/.X11-unix"
  denv_mounts="${denv_mounts} ${denv_entrypoint}"
  case "${denv_runner}" in
    docker|podman)
      interactive=""
      if tty -s; then
        interactive="--interactive --tty"
      fi
      # and need to mount group definition file
      # mounting the passwd and group files may not work if host or contianer OS do not look 
      # there for user/group definitions
      # need to mount PWD just in case we are running outside of a mounted directory
      denv_mounts="${denv_mounts} /etc/passwd /etc/group $(pwd -P)"
      mounts="$(set +o xtrace; _denv_mounts_to_args "--volume")"
      if [ "${denv_workspace}" != "$(pwd -P)" ]; then
        # need to mount workspace manually for docker/podman
        mounts="${mounts} --volume ${denv_workspace}:${denv_workspace}"
      fi
      environment="$(set +o xtrace; _denv_environment_to_args --env)"
      userspec="--user $(id -u "${USER}"):$(id -g "${USER}")"
      if [ "${denv_runner}" = "podman" ]; then
        userspec="--userns=keep-id"
      fi
      network="host"
      [ "${denv_network}" = "false" ] && network="none"
      # shellcheck disable=SC2086,SC2248
      ${denv_runner} run \
        --rm \
        --network "${network}" \
        ${interactive} \
        ${mounts} \
        --hostname "${_hostname}" \
        ${environment} \
        --workdir "$(pwd -P)" \
        --entrypoint "${denv_entrypoint}" \
        ${userspec} \
        "${denv_image}" \
        "$@"
      ;;
    apptainer|singularity)
      # apptainer/singularity do not pull automatically when attempting to run
      _denv_config_checked_pull DO_NOT_PROMPT_USER
      mounts="$(set +o xtrace; _denv_mounts_to_args "--bind")"
      if [ -z "${denv_image_cache+x}" ]; then
        # in a workspace-less shebang running mode, denv_image_cache is unset
        # we assume the user has defined denv_image to be the full path to the image
        # and rely on the runner to have a helpful error message about how the image
        # is not found
        sif_file="${denv_image}"
      else
        # in a workspace, we convert an image name to a filename that can
        # reside in our local cache of image files
        sif_file="${denv_image_cache}/$(_denv_image_to_filename).sif"
      fi
      environment="$(set +o xtrace; _denv_environment_to_args "--env")"
      network=""
      [ "${denv_network}" = "false" ] && network="--net --network none"
      # shellcheck disable=SC2086
      PWD=$(pwd -P) ${denv_runner} exec \
        ${network} \
        --hostname "${_hostname}" \
        --home "${denv_workspace}" \
        --cleanenv \
        ${environment} \
        ${mounts} \
        "${sif_file}" \
        "${denv_entrypoint}" \
        "$@"
      ;;
    norunner)
      network="enabled"
      [ "${denv_network}" = "false" ] && network="disabled"
      _denv_info "running ${denv_image} with " \
        "  HOME=\"${denv_workspace}\"" \
        "  SHELL=\"${denv_shell}\"" \
        "  PWD=\"$(pwd -P)\"" \
        "  network ${network}" \
        "${denv_environment}" \
        "${denv_mounts}"
      ;;
    *)
      _denv_error "This should never happen."
      return 125
      ;;
  esac
}

###################################################################################################
# denv internal helper functions
# 
#  these are the functions defining the CLI, loading the config, writing the config
#  and calling the runner functions defined above in the correct sequence
###################################################################################################

# print the question passed to us and process user input
# continues in infinite loop if user is not explicitly answering yes or no
# Arguments
#  1 - question to ask the user (yes or no)
# Output
#  returns 0 if user answers yes and 1 if user answers no
_denv_user_confirm() {
  question="$*"
  while true; do
    printf "\033[1m%s\033[0m [Y/n] " "${question}"
    read -r ans
    case "${ans}" in
      Y|y|yes)
        return 0
        ;;
      N|n|no)
        return 1
        ;;
      *)
        _denv_error "${ans} is not one of Y, y, yes, N, n, or no."
        ;;
    esac
  done
}

_denv_deduce_workspace() {
  # start from present working directory and go up directories until find .denv
  # or reach root directory
  denv_workspace="$(pwd -P || true)"
  while [ "${denv_workspace}" != "/" ]; do
    if [ -d "${denv_workspace}/.denv" ]; then
      return 0
    fi
    denv_workspace="$(dirname "${denv_workspace}" || true)"
  done
  return 1
}

# deduce the runner we are going to run with
# Arguments
#   DENV_RUNNER environment variable
_denv_deduce_runner() {
  # make sure to update _denv_check and docs/src/manual/denv.md if the order of this elif tree is changed
  if [ -n "${DENV_RUNNER+x}" ]; then
    denv_runner="${DENV_RUNNER}"
    if [ ! "${denv_runner}" = "norunner" ] && ! command -v "${denv_runner}" >/dev/null 2>&1; then
      _denv_error "The container runner set via DENV_RUNNER=${DENV_RUNNER} is not a valid command." \
        "You should only be setting DENV_RUNNER if you have more than one runner installed and wish to use denv with a specific one."
      return 1
    fi
  elif command -v apptainer >/dev/null 2>&1; then
    denv_runner="apptainer"
  elif command -v singularity >/dev/null 2>&1; then
    denv_runner="singularity"
  elif command -v podman >/dev/null 2>&1; then
    denv_runner="podman"
  elif command -v docker >/dev/null 2>&1; then
    denv_runner="docker"
  else
    _denv_error "No container runner available." \
      "Setting 'norunner' which simply allows exploration of CLI."
    denv_runner="norunner"
  fi
  _denv_info "using ${denv_runner} as runner"
}

_denv_bad_env_var_name_regex="^(DENV|HOST|HOSTNAME|HOME|LANG|LC_CTYPE|PATH|SHELL|XDG_.*_DIRS|^_)"

# deduce the environment we should put into the denv
# Arguments
#   parameters related to environment variables in a workspace config
#   denv_env_var_copy_all denv_env_var_copy, denv_env_var_set
#   denv_runner for HOME deduction
# Outputs
#   denv_environment environment variable
_denv_deduce_environment() {
  # deduce environment variables from configuration
  # disable xtrace here to avoid polluting debug printout
  set +o xtrace
  # copy-able environment variables, code copied from distrobox
  copyable_environment="$(printenv | grep '=' | grep -Ev ' |"|`|\$' | grep -Ev "${_denv_bad_env_var_name_regex}")"
  if [ "${denv_env_var_copy_all}" = "true" ]; then
    # deduce env variables, copied from distrobox
    denv_environment="${copyable_environment}"
  else
    match_any_pattern="^($(echo "${denv_env_var_copy}" | sed 's/ /|/g'))="
    denv_environment="$(echo "${copyable_environment}" | grep -E "${match_any_pattern}" || true)"
  fi

  denv_environment="${denv_environment} ${denv_env_var_set}"

  # always add necessary environment variables
  denv_environment="${denv_environment} DENV_NAME=${denv_name}"
  denv_environment="${denv_environment} DENV_RUNNER=${denv_runner}"
  denv_environment="${denv_environment} DENV_IMAGE=${denv_image}"
  case "${denv_runner}" in
    singularity|apptainer)
      # should /not/ pass the HOME environment variable
      # the program handles that when using the --home flag at run time
      ;;
    *)
      denv_environment="${denv_environment} HOME=${denv_workspace}"
      ;;
  esac

  if [ -n "${DENV_DEBUG+x}" ]; then
    # add to the environment
    denv_environment="${denv_environment} DENV_DEBUG=${DENV_DEBUG}"
  fi

  # env sifts out the unique variable names for us and uses the last value set
  # this is the behavior we want since we add the `set` variables _after_
  # the `copy` variables allowing the user to overwrite any host variables
  # disabling double-quote warning so that we can re-split the space-separated list
  # shellcheck disable=SC2086
  denv_environment="$(env -i ${denv_environment})"

  # re-instate xtrace if DENV_DEBUG was done
  if [ -n "${DENV_DEBUG+x}" ]; then
    set -o xtrace
  fi
}

# load the denv config from the input workspace
# Arguments
#  ${denv_workspace} env var
# Outputs
#  loaded config into runtime shell environment
_denv_load_config() {
  # deduce workspace if it isn't already defined
  if [ -z "${denv_workspace+x}" ]; then
    if ! _denv_deduce_workspace; then
      _denv_error "Unable to deduce a denv workspace!" \
      "Are you in a denv workspace? Do you still need to 'denv init'?"
      return 1
    fi
  fi
  # I am choosing to allow sourcing unknown code
  # shellcheck disable=SC1091
  . "${denv_workspace}/.denv/config"
  denv_image_cache="${denv_workspace}/.denv/images"
  _denv_deduce_runner
  _denv_deduce_environment
}

# write the current config to the file
# Arguments
#  ${denv_workspace} env var
#  env - config variables from runtime env
_denv_write_config() {
  config="${denv_workspace}/.denv/config"
  { 
    echo "denv_name=\"${denv_name}\"";
    echo "denv_image=\"${denv_image}\"";
    echo "denv_shell=\"${denv_shell}\"";
    echo "denv_mounts=\"${denv_mounts}\"";
    echo "denv_env_var_copy_all=\"${denv_env_var_copy_all}\"";
    echo "denv_env_var_copy=\"${denv_env_var_copy}\"";
    echo "denv_env_var_set=\"${denv_env_var_set}\"";
    echo "denv_network=\"${denv_network}\"";
  } > "${config}"
}

# print the current denv config
# Arguments
#  all denv_* env vars
#  1 - optional, if provided then print deduced env vars
#      if we aren't copying the host env vars, then we will
#      print them as well, expecting the list to be shorter
_denv_config_print() {
  printf "%s=\"%s\"\n" denv_workspace "${denv_workspace}"
  printf "%s=\"%s\"\n" denv_name "${denv_name}"
  printf "%s=\"%s\"\n" denv_image "${denv_image}"
  printf "%s=\"%s\"\n" denv_mounts "${denv_mounts}"
  printf "%s=\"%s\"\n" denv_shell "${denv_shell}"
  printf "%s=\"%s\"\n" denv_network "${denv_network}"
  _denv_runner
  if [ ! "${denv_env_var_copy_all}" = "true" ] || [ -n "${1:-}" ]; then
    _denv_config_env print
  fi
}

# pull down the ${denv_image} if it doesn't exist
# locally, if it does exist locally, check
# with the user if they wish for denv to pull
# Arguments
#  1 - disable user prompt if provided, just assume no pull
#  denv_image (same as _denv_image_exists and _denv_pull)
_denv_config_checked_pull() {
  if ! _denv_image_exists; then
    _denv_pull
  elif [ -z "${1+x}" ]; then
    if _denv_user_confirm "${denv_image} already exists on this computer - re-pull it?"; then
      _denv_pull
    else
      _denv_info "Not pulling ${denv_image}..."
    fi
  fi
}

# update the image used by the denv
# Arguments
#  1 - new image for the denv
_denv_config_image() {
  case "$1" in
    pull)
      # if argument is keyword 'pull' then we simply
      # pull down with the currently configured image tag
      _denv_pull
      ;;
    *)
      # any other argument should be treated as the 
      # new image tag to use for the denv
      denv_image="$1"
      _denv_config_checked_pull "${DENV_NOPROMPT+DONT_PROMPT_USER}"
      ;;
  esac
}

# set the shell to be used in the container
# Arguments
#  1+ - command to use as shell in the container
# Outputs
#  sets denv_shell to the entire list of arguments
_denv_config_shell() {
  denv_shell="$*"
}

# add another mount point for the container
# Arguments
#  1+ - path to directory to mount to container
# Outputs
#  updates denv_mounts to include passed directories
_denv_config_mounts() {
  while [ "$#" -gt "0" ]; do
    case "$1" in
      /*)
        # this is a full path
        if [ -d "$1" ]; then
          _denv_info "Adding ${1} to mounts"
          denv_mounts="$1 ${denv_mounts}"
        else
          _denv_error "'$1' does not exist."
          return 1
        fi
        ;;
      *)
        _denv_error "'$1' is not a full path"
        return 1
        ;;
    esac
    shift
  done
}

# enable/disable the network connection within the denv
_denv_config_network() {
  case "$1" in
    yes|true|on)
      _denv_info "Enabling network connection"
      denv_network="true"
      ;;
    no|false|off)
      _denv_info "Disabling network connection"
      denv_network="false"
      ;;
    *)
      _denv_error "'$1' is not 'yes', 'on', or 'true' nor 'no', 'off', or 'false'"
      ;;
  esac
}

# configure environment variables for within the denv
# Arguments
#  1 - {all,copy,set}
# Outputs
#  updates the denv_env_var* config variables appropriately
_denv_config_env_help() {
  cat <<\HELP

  denv config env [help|-h|--help]
  denv config env print
  denv config env all {[yes|true|on]|[no|false|off]}
  denv config env copy VAR0[=VAL0] [VAR1[=VAL1] ...]
  denv config env reset

 COMMANDS
  help    print this help and exit
  print   print the deduced environment variables that will be put into the container
  all     configure denv to copy "all" copy-able environment variables
          into the denv (passing yes, true, or on), meaning any variables set to be copied manually
          will be ignored, or disable this copy-all feature (by passing no, false, or off).
  copy    configure denv to copy specific environment variables (the VAR arguments)
          into the denv. This disables the copy all feature as well.
          Any argument with '=' is assumed to be a static KEY=VALUE pair to pass
          into the denv as an environment variable while arguments without '=' have
          the VALUE deduced from the host environment (or left unset if the host environment
          is not set).
  reset   reset the environment variables to be copied into the denv to an empty state.
          Clears the lists of environment variables to be copied and sets "all" to "no".

HELP
}
_denv_config_env() {
  if [ -z "${1}" ]; then
    _denv_config_env_help
    return 1
  fi
  case "$1" in
    help|-h|--help)
      _denv_config_env_help
      return 0
      ;;
    print)
      # disabling double-quote warning so that we can re-split the space-separated list
      # shellcheck disable=SC2086
      printf "%s\n" ${denv_environment}
      ;;
    all)
      shift
      if [ "$#" -eq "0" ]; then
        # default with no arguments is yes
        _denv_info "Copying all copyable host environment variables."
        denv_env_var_copy_all="true"
        return 0;
      fi
      case "$1" in
        no|false|off)
          _denv_info "Only copying envrionment variables specified by user."
          denv_env_var_copy_all="false"
          ;;
        yes|true|on)
          _denv_info "Copying all copyable host environment variables."
          denv_env_var_copy_all="true"
          ;;
        *)
          _denv_error "'$1' is not 'yes', 'on', or 'true' nor 'no', 'off', or 'false'"
          return 1;
          ;;
      esac
      ;;
    copy)
      shift
      while [ "$#" -gt "0" ]; do
        if echo "${1}" | grep -E "${_denv_bad_env_var_name_regex}"; then
          _denv_error "The passed variables named above are special and should not be used in the denv."
          return 1
        fi
        if echo "${1}" | grep -E ' |"|`|\$'; then
          _denv_error "Values cannot use special characters (space ' ', quote '\"', tick '\`', dollar-sign '$')"
          return 1
        fi
        if echo "${1}" | grep -q "="; then
          _denv_info "Setting environment variable in denv '${1}'."
          if [ -z "${denv_env_var_set}" ]; then
            denv_env_var_set="${1}"
          else
            denv_env_var_set="${denv_env_var_set} ${1}"
          fi
        else
          if [ "${denv_env_var_copy_all}" = "true" ]; then
            _denv_error "denv is configured to copy all environment variables from the host already." \
              "If you wish to only copy specific variables, disable copy-all first with 'denv config env all off'."
            return 1
          fi
          _denv_info "Copying host environment variable in denv '${1}'."
          if [ -z "${denv_env_var_copy}" ]; then
            denv_env_var_copy="${1}"
          else
            denv_env_var_copy="${denv_env_var_copy} ${1}"
          fi
        fi
        shift
      done
      ;;
    reset)
      _denv_info "Copying all copyable host environment variables and clearing previous variable lists."
      denv_env_var_copy_all="true"
      denv_env_var_copy=""
      denv_env_var_set=""
      ;;
    *)
      _denv_error "'$1' is not a recognized keyword 'help', 'print', 'all', 'copy', or 'reset'"
      return 1
      ;;
  esac
}

# config some config variable
# Arguments
#  1 - varible to config
#  2 - new value for that variable
_denv_config_help() {
  cat <<\HELP

  denv config [help|-h|--help]
  denv config print [include-env]
  denv config image [pull|IMAGE]
  denv config mounts DIR0 [DIR1 DIR2 ...]
  denv config shell SHELL
  denv config network {[yes|true|on]|[no|false|off]}
  denv config env [args...]

 COMMANDS
  help    print this help and exit
  print   print the deduced config for viewing
          if an argument is provided, then show the environment variables as well
  image   set the image you wish to use
          the special keyword 'pull' can be used to
          not change the image being used but to re-download
          the same tag from the remote repository
  mounts  add one or more directories to be mounted to the denv
  shell   change which program is executed when opening
          the denv without any arguments
  network enable connecting the network to the denv (passing yes, true, or on),
          or disable connecting the network (passing no, false, or off).
  env     configure which environment variables are put
          into the container environment
          `denv config env help` for more detail

HELP
}
_denv_config() {
  if [ $# -eq 0 ]; then
    _denv_config_help
    return 0
  fi
  case "$1" in
    print)
      _denv_load_config
      cmd="_denv_config_${1}"
      ${cmd} "${2:-}"
      ;;
    image|shell|mounts|network|env)
      if [ "$1" = "env" ]; then
        # need to check for help printout before loading config
        # so users can access help information without a denv
        if [ $# -eq 1 ]; then
          _denv_config_env_help
          exit 0
        fi
        case "$2" in
          help|-h|--help)
            _denv_config_env_help
            exit 0
            ;;
          *)
            # fall through to command handling below
            ;;
        esac
      fi
      _denv_load_config
      cmd="_denv_config_${1}"
      if [ "$#" -eq "1" ]; then
        _denv_config_help
        _denv_error "$1 requires an argument."
        return 1
      fi
      shift
      # I think I know what I'm doing
      # shellcheck disable=SC2068
      ${cmd} $@ 
      _denv_write_config
      ;;
    help|-h|--help)
      _denv_config_help
      ;;
    *)
      _denv_error "Unrecognized config argument '$1'"
      return 1
      ;;
  esac
}

# create a new denv workspace
_denv_init_help() {
  cat <<\HELP

  denv init [help|-h|--help] IMAGE [WORKSPACE] [--no-gitignore]
            [--force] [--name NAME] [--clean-env|--no-copy-all]

 ARGUMENT
  help       : print this help and exit
  IMAGE      : the container image to use for running the denv
  WORKSPACE  : the directory to create the denv for
               optional, defaults to present working directory
  
 OPTIONS
  -h, --help      : print this help and exit
  --no-gitignore  : don't generate a gitignore for the .denv directory
  --force         : overwrite an existing denv if it exists and create
                    the WORKSPACE without prompting if it doesn't exist
  --name          : set a name for this denv
  --clean-env     : don't enable copying of host environment variables
                    --no-copy-all is another alias which more closely
                    mimics the underlying implementation and wording of
                    'denv config env'

HELP
}
_denv_init() {
  # check for help request
  if [ $# -eq 0 ]; then
    _denv_init_help
    _denv_error "Provide at least an image to use for running"
    return 1
  fi
  copyall=1
  gitignore=1
  force=1
  positionals=""
  while [ "$#" -gt "0" ]; do
    case "$1" in
      help|-h|--help)
        _denv_init_help
        return 0
        ;;
      --no-gitignore)
        gitignore=0
        ;;
      --clean-env|--no-copy-all)
        copyall=0
        ;;
      --force)
        force=0
        ;;
      --name)
        if [ -z "${2+x}" ]; then
          _denv_error "The '$1' option requires an argument after it."
          return 1
        fi
        denv_name="${2}"
        shift
        ;;
      *)
        positionals="${positionals} ${1}"
        ;;
    esac
    shift
  done
  # I want to re-split the positional arguments because neither
  # of them should have a space inside
  # shellcheck disable=SC2086
  set -- ${positionals}
  # image - first positional and only required argument
  image="$1"
  shift
  # workspace - second positional argument if given, otherwise PWD
  if [ ! "$#" -eq 0 ]; then
    denv_workspace="$1"
    # check if this directory exists, if not create it
    if [ ! -d "${denv_workspace}" ]; then
      if [ "${force}" = "0" ]; then
        _denv_info "creating ${denv_workspace} for the denv workspace"
      elif [ -n "${DENV_NOPROMPT+x}" ]; then
        _denv_error "denv prompt disabled but unwilling to create a directory without user input."
        return 1
      elif ! _denv_user_confirm "This directory does not exist. Would you like to create it for the denv?"; then
        _denv_info "Exiting without creating '${denv_workspace}'..."
        return 0
      fi
      _denv_info "Creating '${denv_workspace}' for the denv..."
      mkdir "${denv_workspace}"
    fi
    _denv_info "Entering '${denv_workspace}'..."
    cd "${denv_workspace}"
  fi
  # if the workspace was given, we have created and entered it, so the workspace is PWD
  denv_workspace="${PWD}"

  # check if we already been init'ed
  if [ -d "${denv_workspace}/.denv" ];then
    if [ "${force}" = "0" ]; then
      _denv_info "overwriting previous denv workspace"
    elif [ -n "${DENV_NOPROMPT+x}" ]; then
      _denv_error "denv prompt disabled but unwilling to overwrite a denv without user input."
      return 1
    elif ! _denv_user_confirm "This workspace already has a denv. Would you like to overwrite it?"; then
      _denv_info "Exiting without overwriting denv within '${denv_workspace}'..."
      return 0
    fi
  else
    mkdir "${denv_workspace}/.denv"
  fi

  # set the default denv name to the workspace directory name
  if [ -z "${denv_name+x}" ]; then
    denv_name="$(basename "${denv_workspace}")"
  fi
  # we have a clean workspace directory, lets make a new denv
  denv_image="${image}"
  denv_shell="/bin/bash -i"
  denv_mounts=""
  denv_network="true"
  if [ "${copyall}" = "1" ]; then
    denv_env_var_copy_all="true"
  else
    denv_env_var_copy_all="false"
  fi
  denv_env_var_copy=""
  denv_env_var_set=""
  _denv_write_config
  if [ "${gitignore}" = "1" ]; then
    _denv_info "Writing a gitignore for the .denv directory."
    cat > "${denv_workspace}/.denv/.gitignore" <<\GITIGNORE
# ignore everything in this directory
*
# except the config which folks might want to share
# across many computers
!config
GITIGNORE
  fi

  # reload config for any deduced parameters
  _denv_load_config
  _denv_config_checked_pull "${DENV_NOPROMPT+DONT_PROMPT_USER}"
}

# print the denv version
_denv_version() {
  echo "denv v${denv_version}"
}

# check that denv was installed alongside its entrypoint and there
# is a runner available to use
_denv_check_help() {
  cat <<\HELP

  denv check [-h, --help] [-q, --quiet] [--workspace]

 DESCRIPTION
  Check denv installation to make sure the entrypoint exists as
  an executable file in the expected location, there is at least
  one container runner available for denv to use, and a workspace
  has been initialized.

  This command (without the -q, --quiet flag) lists the runners it
  is looking for, the ones that it has found, and which runner will
  be used by default if DENV_RUNNER is not set in the environment.

  EXIT CODES
    0   : success, denv installation is complete and there is a supported runner to use
    1   : failure, denv cannot find the entrypoint script it needs
    2   : failure, denv cannot find a supported runner to use
    3   : failure, DENV_RUNNER is defined to a runner that denv does not support
          or is not an available program on the current machine
    4   : failure, denv cannot deduce a workspace (i.e. no 'denv init' has happened yet)
          only tested if the --workspace option is provided
    127 : denv check was supplied an argument it didn't recognize

 OPTIONS
  -h, --help  : print this help and exit
  -q, --quiet : suppress non-error output, i.e. will silently return 0 if
                denv can function properly
  --workspace : check if denv can deduce a workspace from the current directory

HELP
}
_denv_check() {
  quiet=false
  workspace=false
  while [ "$#" -gt "0" ]; do
    case "$1" in
      -h|--help)
        _denv_check_help
        return 0
        ;;
      -q|--quiet)
        quiet=true
        ;;
      --workspace)
        workspace=true
        ;;
      *)
        _denv_error "Unrecognized 'denv check' option '$1'"
        return 127
        ;;
    esac
    shift
  done
  # check for entrypoint
  if [ -x "${denv_entrypoint}" ] && [ -f "${denv_entrypoint}" ]; then
    ${quiet} || printf "\033[32mEntrypoint found alongside denv\033[0m\n"
  else
    _denv_error "_denv_entrypoint does not exist as an executable file alongside denv"
    return 1
  fi

  first="true"
  would_run_with="norunner"
  denv_runner_defined=false
  denv_runner_matched=false
  if [ -n "${DENV_RUNNER:+x}" ]; then
    denv_runner_defined=true
    would_run_with="${DENV_RUNNER}"
  fi
  # the order in this for loop should be the same as the order of
  # the elif-tree in _denv_load_config so that we correctly inform
  # the user which runner would be deduced when running
  for possible in apptainer singularity podman docker;
  do
    ${quiet} || printf "Looking for %s... " "${possible}"
    if command -v "${possible}" >/dev/null 2>&1; then
      # extra version compatibility checking
      case "${possible}" in
        singularity)
          version="$(singularity version | cut -f 1 -d '-')"
          major="$(echo "${version}" | cut -f 1 -d '.')"
          minor="$(echo "${version}" | cut -f 2 -d '.')"
          #patch="$(echo "${version}" | cut -f 3 -d '.')" # not used
          if singularity --version 2>&1 | grep -q apptainer; then
            ${quiet} || printf "found apptainer emulating singularity"
          elif [ "${major}" -lt "3" ] || [ "${major}" -eq "3" ] && [ "${minor}" -lt "6" ]; then
            ${quiet} || printf "found '%s', but " "$(singularity --version)"
            ${quiet} || printf "\033[31m%s\033[0m" \
              "denv requires the --env flag for singularity which was introduced in v3.6"
          else
            ${quiet} || printf "\033[32mfound '%s'\033[0m" "$(${possible} --version)"
          fi
          ;;
        docker)
          # check for podman emulation of docker
          # if podman is emulating docker, docker --version will return podman --version
          # which includes 'podman'
          if docker version 2>&1 | grep -iq podman; then
            ${quiet} || printf "found podman emulating docker"
          else
            ${quiet} || printf "\033[32mfound '%s'\033[0m" "$(${possible} --version)"
          fi
          ;;
        *)
          # no extra checking, just print the version found
          ${quiet} || printf "\033[32mfound '%s'\033[0m" "$(${possible} --version)"
          ;;
      esac
      if ${denv_runner_defined}; then
        if [ "${possible}" = "${DENV_RUNNER}" ]; then
          denv_runner_matched=true
          ${quiet} || printf "\033[32;1m <- DENV_RUNNER\033[0m"
        fi
      fi
      if [ "${first}" = "true" ]; then
        ${quiet} || printf "\033[32;1m <- use without DENV_RUNNER defined\033[0m"
        first="false"
        ${denv_runner_defined} || would_run_with="${possible}"
      fi
    else
      ${quiet} || printf "not found"
    fi
    ${quiet} || printf "\n"
  done
  if [ "${first}" = "true" ]; then
    _denv_error "No container runner found!"
    return 2
  else
    ${quiet} || printf "denv would run with '%s'\n" "${would_run_with}"
  fi
  if ${denv_runner_defined} && ! ${denv_runner_matched}; then
    _denv_error "DENV_RUNNER=${DENV_RUNNER} but this runner is not supported by denv" \
      "(or is not available on this machine)"
    return 3
  fi
  if ${workspace}; then
    if [ -z "${denv_workspace+x}" ] && ! _denv_deduce_workspace; then
      _denv_error "Unable to deduce a denv workspace" \
        "You may need to just 'denv init' in the directory of your choice."
      return 4
    else
      ${quiet} || printf "Found denv_workspace=\"%s\"\n" "${denv_workspace}"
    fi
  fi
  return 0
}

_denv_shebang() {
  lines=0
  # scan first 10 lines of the file
  # (10 = 8 config variables, 1 workspace variable, 1 original shebang)
  while read -r line && [ "${lines}" -ne 10 ]; do
    lines=$((lines + 1))
    unset shebang_line
    if [ "${line#\#!}" != "${line}" ]; then
      shebang_line="${line#\#!}"
    elif [ "${line#//!}" != "${line}" ]; then      # // comments
      shebang_line="${line#//!}"
    elif [ "${line#--!}" != "${line}" ]; then      # -- lua comments
      shebang_line="${line#--!}"
    elif [ "${line#<?php\ }" != "${line}" ]; then  # php comments
      shebang_line="${line#<?php\ \#!}"
      shebang_line="${shebang_line%\ ?>}"
    fi

    # skip lines that didn't have the shebang
    if [ -z "${shebang_line:+x}" ]; then
      continue
    fi

    # skip the shebang the says we are using denv shebang
    if [ "${shebang_line#*denv shebang}" != "${shebang_line}" ]; then
      continue
    fi

    # if a shebang line starts with 'denv_' then we assume it is one
    # of the config variables and `eval` it to bring it into this context
    if [ "${shebang_line#"denv_"}" != "${shebang_line}" ]; then
      eval "${shebang_line}"
    fi

    # the shebang line is not our shebang or a denv_* config variable,
    # so we expect it to be the program to run inside the denv
    program_line="${shebang_line}"
  done < "$1"

  if [ -n "${denv_workspace+x}" ]; then
    # prefer denv_workspace, if its defined load the config from that area
    # NOTE: This will overwrite any variables given in the shebang with the ones in
    # the workspace config
    _denv_load_config
  elif [ -n "${denv_image+x}" ]; then
    # no denv_workspace but an image is defined
    # in order to support a workspace-less running mode,
    # we prepare default values for all unset config parameters
    denv_workspace="$(pwd -P)"
    [ -n "${denv_name+x}" ] || denv_name="workspaceless"
    [ -n "${denv_shell+x}" ] || denv_shell="/bin/bash -i"
    [ -n "${denv_mounts+x}" ] || denv_mounts=""
    [ -n "${denv_network+x}" ] || denv_network="true"
    [ -n "${denv_env_var_copy_all+x}" ] || denv_env_var_copy_all="true"
    [ -n "${denv_env_var_copy+x}" ] || denv_env_var_copy=""
    [ -n "${denv_env_var_set+x}" ] || denv_env_var_set=""
    _denv_deduce_runner
    _denv_deduce_environment
  else
    _denv_error "Either denv_workspace or denv_image are required within a denv shebang."
    exit 1
  fi

  script_dir="$(dirname "${1}")"
  script_dir="$(cd "${script_dir}" && pwd -P)"
  script_fullpath="${script_dir}/$(basename "${1}")"

  # script is now stored, go to rest of arguments
  shift
 
  # make sure file we are running is accessible in the denv
  denv_mounts="${script_fullpath} ${denv_mounts}"
  # run the file in the denv
  _denv_run "${program_line}" "${script_fullpath}" "$@"
}

# root program denv
_denv_help() {
  cat <<\HELP

  denv [COMMAND] [args...]

 DESCRIPTION
  interact with a containerized developers environment

  If no COMMAND is provided, open an interactive shell in
  the currently configured denv.

 COMMANDS
  version : print the version of denv
  init    : initialize a new denv with an image
  config  : modify current denv configuration
  check   : checks for denv (installed, runner available, init done)
  help    : print this help and exit
  <cmd>   : run <cmd> inside denv container

HELP
}
_denv() {
  if [ $# -eq 0 ]; then
    if ! _denv_load_config; then
      # we failed to load the config and the user did not provide any arguments,
      # lets at least print the help just in case this is a new user
      _denv_help
      return 1
    fi
    # shellcheck disable=SC2086
    _denv_run ${denv_shell}
    return $?
  fi

  case "$1" in
    -h|--help)
      _denv_help
      return 
      ;;
    version|help|config|init|check|shebang)
      cmd="_denv_${1}"
      shift
      # I think I know what I'm doing here
      # shellcheck disable=SC2068
      ${cmd} $@
      return $?
      ;;
    *)
      _denv_load_config
      # I think I know what I'm doing here
      # shellcheck disable=SC2068
      _denv_run $@
      return $?
      ;;
  esac
}

# I think I know what I'm doing here
# shellcheck disable=SC2068
_denv $@
