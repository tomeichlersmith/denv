.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "DENV" "1" "Jun 2024" "denv" "User Manual"
.hy
.SH NAME
.PP
denv v0.8.1
.SH SYNOPSIS
.PP
\f[B]denv\f[R] {help|-h|\[en]help}
.PP
\f[B]denv\f[R] version
.PP
\f[B]denv\f[R] init [args]
.PP
\f[B]denv\f[R] config [args]
.PP
\f[B]denv\f[R] check [-h, \[en]help] [-q, \[en]quiet]
.PP
\f[B]denv\f[R] [COMMAND] [args\&...]
.SH DESCRIPTION
.PP
\f[B]\f[CB]denv\f[B]\f[R] is a light, POSIX-compliant wrapper around a
few common container managers, allowing the user to efficiently interact
with container-ized envorinments uniformly across systems with different
installed managers.
It has few commands, prioritizing simplicity so that users can easily
and quickly pass their own commands to be run within the specialized and
isolated environment.
.SH COMMANDS
.PP
\f[B]\f[CB]help\f[B]\f[R] prints a short help message and exits.
The aliases \f[B]\f[CB]-h\f[B]\f[R] and \f[B]\f[CB]--help\f[B]\f[R] also
exist for this command.
.PP
\f[B]\f[CB]version\f[B]\f[R] prints the name and version of the
currently installed \f[C]denv\f[R]
.PP
\f[B]\f[CB]init\f[B]\f[R] initialize a new denv.
See \f[B]denv-init(1)\f[R] for details.
.PP
\f[B]\f[CB]config\f[B]\f[R] manipulate the configuration of the current
denv.
See \f[B]denv-config(1)\f[R] for details.
.PP
\f[B]\f[CB]check\f[B]\f[R] check the installation of denv and look for
supported container runners.
See \f[B]denv-check(1)\f[R] for details.
.PP
\f[B]\f[CB]COMMAND\f[B]\f[R] any other command not matching one of the
options above is provided to the configured denv to run within the
containerized environment.
The rest of the command line is passed along with COMMAND so its args
are seen as if they were run manually within the shell of the container.
.SH EXAMPLES
.PP
\f[B]\f[CB]denv\f[B]\f[R] is meant to be used after building a
containerized developer environment.
Look at the online manual for help getting started on developing the
environment itself, but for these examples, we will assume that you
already have an image built in which you wish to develop.
.SS Basic Start-Up
.PP
First, we go into the directory that holds the code we wish to develop
and tell denv that this workspace should be running a specific image for
its developer environment.
.IP
.nf
\f[C]
denv init myuser/myrepo:mytag
\f[R]
.fi
.PP
Then we can open a shell in the denv.
.IP
.nf
\f[C]
denv
\f[R]
.fi
.PP
Now you can build and run programs from within the denv with its
solidified set of software and tools while still editing the code files
themselves with whatever text editor you wish outside of the denv.
The init command produces a configuration file \f[C].denv/config\f[R]
which you can share between users and so it is excluded from the default
\f[C].gitignore\f[R] generated within \f[C].denv\f[R].
All other files within \f[C].denv\f[R] are internal to denv and can only
be modified at your own risk.
.SH SEE ALSO
.PP
\f[B]denv-init(1)\f[R], \f[B]denv-config(1)\f[R],
\f[B]denv-check(1)\f[R]
.SH ENVIRONMENT
.PP
denv tests the definition and reads the value of a few different
environment variables - allowing the user to modify its behavior in an
advanced way without having to provide many command line arguments.
.PP
\f[B]DENV_DEBUG\f[R] if set, enable xtrace in denv so the user can see
exactly what commands are being run.
.PP
\f[B]DENV_INFO\f[R] if set, print progress information updates to
terminal while denv is running
.PP
\f[B]DENV_RUNNER\f[R] set to the container manager command you wish denv
to use.
This should only be used in the case where multiple managers are
installed and you wish to override the default denv behavior of using
the first runner that it finds available.
.PP
\f[B]DENV_NOPROMPT\f[R] disable all user prompting.
This makes the following decisions in the places where there would be
prompts.
.IP \[bu] 2
\f[B]denv init\f[R] errors out if there is already a denv in the deduced
workspace or if a passed workspace does not exist
.IP \[bu] 2
\f[B]denv init\f[R] and \f[B]denv config image\f[R] will not pull an
image if it already exists
.PP
\f[B]DENV_TAB_COMMANDS\f[R] a space-separated list of commands to
include in tab-completions of denv.
This is helpful if there are a set of common commands you use within the
denv.
.SH SCRIPTING
.PP
denv has a shebang subcommand that can be used to construct a script to
be run by a certain program within a constructed denv.
denv\[cq]s shebang consists of several lines all beginning with the
shebang signal characters \f[C]#!\f[R].
It begins with a normal Unix shebang.
\f[C]/usr/bin/env\f[R] is used to avoid having to type the full path to
denv and \f[C]-S\f[R] is used so the whitespace between \f[C]denv\f[R]
and \f[C]shebang\f[R] is respected (i.e.\ split).
.IP
.nf
\f[C]
#!/usr/bin/env -S denv shebang
\f[R]
.fi
.PP
The following lines of the script file can then contain the
configuration of the denv.
This can be done in two ways.
If you already have a denv workspace that you want to run inside of, you
can just specify that
.IP
.nf
\f[C]
#!denv_workspace=/full/path/to/workspace
\f[R]
.fi
.PP
If you don\[cq]t have a workspace, then you will need to define the
configuration of the denv.
At minimum, you must inform denv which image it should be running.
.IP
.nf
\f[C]
#!denv_image=python:3
\f[R]
.fi
.PP
For singularity or apptainer runners, you need to pre-build this image
since, without a workspace, denv doesn\[cq]t know where it should put
the intermediary image file.
.IP
.nf
\f[C]
#!denv_image=/full/path/to/image.sif
\f[R]
.fi
.PP
Other denv configuration options can be specified in this running mode
as well.
The easiest way to see the options is to inspect the output of
\f[C]denv config print\f[R] which will contain the options not related
to environment variables.
A full listing of available options is given by any \f[C]config\f[R]
file written by denv into a \f[C].denv\f[R] directory for a workspace.
When running from a workspace (i.e.\ when providing
\f[C]denv_workspace\f[R] within the shebang lines), the other options
are \f[I]ignored\f[R] in favor of reading them from the workspace
configuration.
.PP
The last line of the shebang lines is then the program that will be run
with the file and the rest of the command line.
This program is run within the denv so it does not need to reside on the
host system.
The path does not need to even be a full path like with the normal unix
shebang.
The following examples hope to give some more context for how to get
started with denv\[cq]s shebang.
.SS Workspace Example
.IP
.nf
\f[C]
#!/usr/bin/env -S denv shebang
#!denv_workspace=/full/path/to/workspace
#!program
script for program
\f[R]
.fi
.SS Workspace-Less Example (singularity or apptainer)
.IP
.nf
\f[C]
#!/usr/bin/env -S denv shebang
#!denv_image=/full/path/to/image.sif
#!program
script for program
\f[R]
.fi
.SS Workspace-Less Example (other runners)
.IP
.nf
\f[C]
#!/usr/bin/env -S denv shebang
#!denv_image=owner/repo:tag
#!program
script for program
\f[R]
.fi
.SH RUNNER DEDUCTION
.PP
denv does not persist what runner is being used inside of its
configuration for a specific workspace.
This is done intentionally so that configurations could be shared across
machines that may rely on different runners; however, this could lead to
confusion if denv is being used on a machine that has multiple runners
installed.
In this case, it is highly suggested to use
\f[B]\f[CB]denv check\f[B]\f[R] and test-run the different runners to
see which are capable of being used by denv.
.IP
.nf
\f[C]
# lists which runners it supports and which ones it has found
denv check
\f[R]
.fi
.PP
A simple test would be to make sure denv can open a shell in some ubuntu
image.
Check different runners by using the environment variable
\f[C]DENV_RUNNER\f[R].
.IP
.nf
\f[C]
denv init ubuntu:22.04
# run this for each of the runners \[dq]found\[dq] by denv check
DENV_RUNNER=<runner> denv
\f[R]
.fi
.PP
If any of the runners do not work (i.e.\ open an interactive bash
terminal), please make a bug report by opening an issue for further
investigation.
However, there are some configurations of popular container runners that
denv does not intend to support, so you may be forced to use a specific
container runner out of the ones installed.
In this case, it is highly recommended to define the
\f[C]DENV_RUNNER\f[R] environment variable in your
\f[C]\[ti]/.bashrc\f[R] (or equivalent) to avoid complication.
.SS Automatic Deduction
.PP
denv does make some attempts to avoid this complexity by having an
automatic choosing behavior that prefers runners that are more likely to
be configured properly.
For this reason, denv chooses to prefer runners that act as emulators
over the runners they are emulating (for example, podman is checked
before docker and apptainer is checked before singularity).
In addition, since the configuration of podman on some computing
clusters is not supportive of denv and apptainer is installed on these
clusters, apptainer is checked before podman.
This leads to the following order of priority currently within denv when
\f[C]DENV_RUNNER\f[R] is not defined.
.IP "1." 3
apptainer
.IP "2." 3
singularity
.IP "3." 3
podman
.IP "4." 3
docker
.SH FILES
.PP
This part of the manual is an attempt to list and explain the files
within a \f[C].denv\f[R] directory.
.SS config
.PP
The file storing the configuration of the denv related to this
workspace.
While it is plain-text and you can edit it directly.
Editing it with the denv config set of commands is helpful for doing
basic typo- and existence- checking.
The config file is a basic key=value shell file that will be sourced by
denv.
See the FILES section of \f[B]denv-config(1)\f[R] for more detail.
.SS skel-init
.PP
This is an empty file that, if it exists, signals to the entrypoint
executable that the files from /etc/skel have been copied into the denv
home directory.
This prevents accidental overwriting of files that the user may edit as
well as saving time when starting up the container.
.SS images
.PP
This is a directory that holds any image files that may be generated by
the runner denv is using to run the container.
For some runners, it is helpful to explicitly build an image outside of
the cache directory and then run that image file.
This directory holds those images.
It can be deleted if the user wishes to reclaim some disk space;
however, that means any image that are configured to be used by denv
will then be re-downloaded and re-built.
